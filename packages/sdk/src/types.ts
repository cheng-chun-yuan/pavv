/**
 * BLSGun SDK — Shared type definitions
 */

// ─── Curve Types ──────────────────────────────────────────────────────────────

/** Affine point on Grumpkin curve */
export interface GrumpkinPoint {
  x: bigint;
  y: bigint;
}

/** The point at infinity (identity element) */
export const POINT_AT_INFINITY: GrumpkinPoint = { x: 0n, y: 0n };

// ─── Key Management Types ─────────────────────────────────────────────────────

/** FROST key share for a single signer */
export interface KeyShare {
  index: bigint; // Signer index (1..n)
  rank: number; // Derivative order (0 = standard eval, 1 = first derivative, etc.)
  secretShare: bigint; // Shamir share k_i = f^(rank)(index)
  publicShare: GrumpkinPoint; // PK_i = [k_i]G
}

/** Pre-computed FROST nonce pair for 1-round signing */
export interface NoncePair {
  d: bigint; // Hiding nonce (private)
  e: bigint; // Binding nonce (private)
  D: GrumpkinPoint; // [d]G (public commitment)
  E: GrumpkinPoint; // [e]G (public commitment)
}

/** Complete key material for a signer */
export interface SignerKeyMaterial {
  share: KeyShare;
  nonces: NoncePair[];
  viewingKey: bigint; // All signers get full viewing key for balance scanning
}

/** Master key package (output of keygen ceremony) */
export interface MasterKeyPackage {
  threshold: number; // t (minimum signers to spend)
  groupPublicKey: GrumpkinPoint; // PK_group = [k]G
  shares: KeyShare[]; // n shares for t-of-n
  viewingSecretKey: bigint;
  viewingPublicKey: GrumpkinPoint;
}

/** Hierarchical key package with rank assignments */
export interface HierarchicalKeyPackage extends MasterKeyPackage {
  signerRanks: { index: bigint; rank: number }[];
}

// ─── Transaction Types ────────────────────────────────────────────────────────

/** Encrypted note representing a UTXO */
export interface Note {
  owner: bigint; // Stealth public key hash
  asset: string; // Token address (or "CFX" for native)
  amount: bigint; // Value (hidden on-chain)
  blinding: bigint; // Randomness for commitment
}

/** Commitment leaf in the Merkle tree */
export interface CommitmentLeaf {
  commitment: bigint; // Poseidon hash of note data
  leafIndex: number; // Position in the Merkle tree
}

/** Merkle proof for a commitment */
export interface MerkleProof {
  pathElements: bigint[]; // Sibling hashes along the path
  pathIndices: number[]; // 0 = left, 1 = right
  root: bigint; // Tree root at time of proof
}

/** Unsigned transaction (before FROST signing) */
export interface UnsignedTransaction {
  inputNullifiers: bigint[];
  outputCommitments: bigint[];
  fee: bigint;
  deadline: bigint;
  message: bigint; // M = Poseidon(nullifiers || commitments || fee || deadline)
}

/** FROST Schnorr signature */
export interface FrostSignature {
  R: GrumpkinPoint; // Group nonce point
  z: bigint; // Aggregated response scalar
}

/** Partial FROST signature from one signer */
export interface PartialSignature {
  signerIndex: bigint;
  z_i: bigint; // Partial response
  R: GrumpkinPoint; // Shared group nonce (same for all signers in a session)
}

/** Complete signed transaction with ZK proof */
export interface SignedTransaction {
  inputNullifiers: bigint[];
  outputCommitments: bigint[];
  fee: bigint;
  deadline: bigint;
  signature: FrostSignature;
  proof: Uint8Array; // ZK proof bytes
}

// ─── Stealth Address Types ────────────────────────────────────────────────────

/** Stealth meta-address (published by recipient) */
export interface StealthMetaAddress {
  spendingPublicKey: GrumpkinPoint; // PK_spend
  viewingPublicKey: GrumpkinPoint; // PK_view
}

/** One-time stealth address (generated by sender) */
export interface StealthAddress {
  address: GrumpkinPoint; // One-time stealth public key
  ephemeralPublicKey: GrumpkinPoint; // Published on-chain for recipient to find
  viewTag: bigint; // Short tag for efficient scanning
  stealthScalar: bigint; // Sender uses for XOR amount encryption
}

// ─── Signing Session Types ────────────────────────────────────────────────────

/** FROST signing session state */
export interface SigningSession {
  message: bigint;
  participants: bigint[]; // Signer indices participating (e.g., [1n, 2n])
  participantRanks?: Map<bigint, number>; // Optional rank info for hierarchical FROST
  nonceCommitments: Map<bigint, { D: GrumpkinPoint; E: GrumpkinPoint }>;
  partials: PartialSignature[];
  groupPublicKey: GrumpkinPoint;
}

// ─── Audit Types ──────────────────────────────────────────────────────────────

/** Decrypted transaction for audit */
export interface AuditTransaction {
  nullifier: bigint;
  commitment: bigint;
  amount: bigint;
  recipient: string;
  timestamp: number;
  blockNumber: number;
}

/** Audit report output */
export interface AuditReport {
  period: { fromBlock: number; toBlock: number };
  transactions: AuditTransaction[];
  totalInflow: bigint;
  totalOutflow: bigint;
  generatedAt: number;
}

// ─── Circuit Witness Types ────────────────────────────────────────────────────

/** Inputs for the Noir ZK circuit */
export interface CircuitInputs {
  // Private inputs
  signature_R_x: string;
  signature_R_y: string;
  signature_z_lo: string;
  signature_z_hi: string;
  group_pubkey_x: string;
  group_pubkey_y: string;
  spending_key_hash: string;
  note_amount: string;
  note_blinding: string;
  merkle_path: string[];
  merkle_indices: string[];
  // Public inputs
  nullifier: string;
  commitment: string;
  merkle_root: string;
}

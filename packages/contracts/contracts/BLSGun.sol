// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

import "./MerkleTree.sol";

/**
 * @title IVerifier
 * @notice Interface for the Noir-generated ZK proof verifier
 */
interface IVerifier {
    function verify(
        bytes calldata proof,
        bytes32[] calldata publicInputs
    ) external returns (bool);
}

/**
 * @title BLSGun
 * @notice Privacy-preserving B2B treasury with 2-of-3 FROST threshold signing in ZK.
 *
 * @dev The FROST Schnorr signature is verified INSIDE the ZK proof.
 *      The contract only needs to:
 *      1. Verify the ZK proof
 *      2. Check nullifiers (prevent double-spend)
 *      3. Manage the commitment Merkle tree
 *
 *      No signature parsing, no pairing checks, no public key exposure on-chain.
 */
contract BLSGun is MerkleTree {
    // ZK proof verifier (generated by bb from Noir circuit)
    IVerifier public immutable verifier;

    // Nullifier set (spent notes)
    mapping(bytes32 => bool) public nullifiers;

    // Events
    event Shield(
        address indexed sender,
        bytes32 indexed commitment,
        uint256 amount
    );

    event PrivateTransfer(
        bytes32 indexed nullifier,
        bytes32 indexed outputCommitment
    );

    event Unshield(
        bytes32 indexed nullifier,
        address indexed recipient,
        uint256 amount
    );

    constructor(address _verifier) {
        verifier = IVerifier(_verifier);
    }

    /**
     * @notice Shield: Deposit tokens into the privacy pool.
     * @param commitment The Poseidon commitment hiding the note details.
     * @dev Accepts native CFX. The commitment is inserted into the Merkle tree.
     */
    function shield(bytes32 commitment) external payable {
        require(msg.value > 0, "Must deposit value");
        require(commitment != bytes32(0), "Invalid commitment");

        _insertLeaf(commitment);

        emit Shield(msg.sender, commitment, msg.value);
    }

    /**
     * @notice Private Transfer: Move funds within the privacy pool.
     * @param nullifier The nullifier of the spent note (prevents double-spend).
     * @param outputCommitment The new note commitment for the recipient.
     * @param proof The ZK proof (proves FROST sig + tx validity inside ZK).
     *
     * @dev The ZK proof implicitly verifies:
     *      - The FROST 2-of-3 Schnorr signature is valid
     *      - The nullifier is correctly derived
     *      - The commitment is correctly constructed
     *      - The input note exists in the Merkle tree
     */
    function privateTransfer(
        bytes32 nullifier,
        bytes32 outputCommitment,
        bytes calldata proof
    ) external {
        // 1. Check nullifier not already spent
        require(!nullifiers[nullifier], "Note already spent");

        // 2. Build public inputs array for verifier
        // Public inputs: [nullifier, commitment, merkle_root]
        // Noir public inputs are 19 total (16 from proof overhead + 3 from circuit)
        // The actual public inputs from our circuit are the last 3
        bytes32[] memory publicInputs = new bytes32[](3);
        publicInputs[0] = nullifier;
        publicInputs[1] = outputCommitment;
        publicInputs[2] = root;

        // 3. Verify ZK proof
        require(verifier.verify(proof, publicInputs), "Invalid proof");

        // 4. Mark nullifier as spent
        nullifiers[nullifier] = true;

        // 5. Insert new commitment into Merkle tree
        _insertLeaf(outputCommitment);

        emit PrivateTransfer(nullifier, outputCommitment);
    }

    /**
     * @notice Unshield: Withdraw funds from the privacy pool.
     * @param nullifier The nullifier of the spent note.
     * @param recipient The address to receive the withdrawn funds.
     * @param amount The amount to withdraw.
     * @param proof The ZK proof.
     */
    function unshield(
        bytes32 nullifier,
        address payable recipient,
        uint256 amount,
        bytes calldata proof
    ) external {
        require(!nullifiers[nullifier], "Note already spent");
        require(amount > 0, "Amount must be positive");
        require(
            address(this).balance >= amount,
            "Insufficient pool balance"
        );

        // Build public inputs
        bytes32[] memory publicInputs = new bytes32[](3);
        publicInputs[0] = nullifier;
        publicInputs[1] = bytes32(amount); // amount as commitment for unshield
        publicInputs[2] = root;

        // Verify ZK proof
        require(verifier.verify(proof, publicInputs), "Invalid proof");

        // Mark nullifier as spent
        nullifiers[nullifier] = true;

        // Transfer funds
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Transfer failed");

        emit Unshield(nullifier, recipient, amount);
    }

    /**
     * @notice Check if a nullifier has been spent.
     */
    function isNullifierSpent(bytes32 nullifier) external view returns (bool) {
        return nullifiers[nullifier];
    }

    /**
     * @notice Get the current Merkle root.
     */
    function getMerkleRoot() external view returns (bytes32) {
        return root;
    }

    /**
     * @notice Get the number of commitments in the tree.
     */
    function getCommitmentCount() external view returns (uint256) {
        return nextLeafIndex;
    }

    // Allow receiving ETH/CFX
    receive() external payable {}
}
